"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const nock = require("nock");
const querystring = require("querystring");
const http_1 = require("./http");
nock.disableNetConnect();
let api;
beforeEach(() => {
    api = nock('https://api.jdxcode.com');
});
afterEach(() => {
    api.done();
});
afterEach(() => {
    nock.cleanAll();
});
describe('HTTP.get()', () => {
    test('makes a GET request', async () => {
        api.get('/').reply(200, { message: 'ok' });
        let { body } = await http_1.HTTP.get('https://api.jdxcode.com');
        expect(body).toEqual({ message: 'ok' });
    });
    test('makes a GET request', async () => {
        api.get('/').reply(200, { message: 'ok' }, {
            'content-type': 'application/json; charset=UTF-8',
        });
        let { body } = await http_1.HTTP.get('https://api.jdxcode.com');
        expect(body).toEqual({ message: 'ok' });
    });
    test('gets headers', async () => {
        api.get('/').reply(200, { message: 'ok' }, { myheader: 'ok' });
        let { body, headers } = await http_1.HTTP.get('https://api.jdxcode.com');
        expect(body).toEqual({ message: 'ok' });
        expect(headers).toMatchObject({ myheader: 'ok' });
    });
    test('can build a new HTTP with defaults', async () => {
        const MyHTTP = http_1.HTTP.create({ host: 'api.jdxcode.com' });
        api.get('/').reply(200, { message: 'ok' });
        let { body } = await MyHTTP.get('/');
        expect(body).toEqual({ message: 'ok' });
    });
    test('makes a request to a port', async () => {
        api = nock('https://api.jdxcode.com:3000');
        api.get('/').reply(200, { message: 'ok' });
        let { body } = await http_1.HTTP.get('https://api.jdxcode.com:3000');
        expect(body).toEqual({ message: 'ok' });
    });
    test('allows specifying the port', async () => {
        api = nock('https://api.jdxcode.com:3000');
        api.get('/').reply(200, { message: 'ok' });
        let { body } = await http_1.HTTP.get('https://api.jdxcode.com', { port: 3000 });
        expect(body).toEqual({ message: 'ok' });
    });
    test('makes a http GET request', async () => {
        api = nock('http://api.jdxcode.com');
        api.get('/').reply(200, { message: 'ok' });
        let { body } = await http_1.HTTP.get('http://api.jdxcode.com');
        expect(body).toEqual({ message: 'ok' });
    });
    test('can set default user agent', async () => {
        http_1.HTTP.defaults.headers = { 'user-agent': 'mynewuseragent' };
        api
            .matchHeader('user-agent', `mynewuseragent`)
            .get('/')
            .reply(200, { message: 'ok' });
        let { body } = await http_1.HTTP.get('https://api.jdxcode.com/');
        expect(body).toEqual({ message: 'ok' });
        delete http_1.HTTP.defaults.headers['user-agent'];
    });
    test('can set user agent as a global', async () => {
        global['http-call'] = { userAgent: 'mynewuseragent' };
        api
            .matchHeader('user-agent', `mynewuseragent`)
            .get('/')
            .reply(200, { message: 'ok' });
        let { body } = await http_1.HTTP.get('https://api.jdxcode.com/');
        expect(body).toEqual({ message: 'ok' });
        delete global['http-call'];
    });
    test('sets user-agent header', async () => {
        api
            .matchHeader('user-agent', `http-call/${require('../package.json').version} node-${process.version}`)
            .get('/')
            .reply(200, { message: 'ok' });
        await http_1.HTTP.get('https://api.jdxcode.com');
    });
    test('sets custom headers', async () => {
        api
            .matchHeader('foo', 'bar')
            .get('/')
            .reply(200);
        let headers = { foo: 'bar' };
        await http_1.HTTP.get('https://api.jdxcode.com', { headers });
    });
    test('does not fail on undefined header', async () => {
        api.get('/').reply(200);
        let headers = { foo: undefined };
        await http_1.HTTP.get('https://api.jdxcode.com', { headers });
    });
    describe('wait mocked out', () => {
        let wait = http_1.HTTP.prototype._wait;
        beforeAll(() => {
            http_1.HTTP.prototype._wait = jest.fn();
        });
        afterAll(() => {
            http_1.HTTP.prototype._wait = wait;
        });
        test('retries then succeeds', async () => {
            api.get('/').replyWithError({ message: 'timed out 1', code: 'ETIMEDOUT' });
            api.get('/').replyWithError({ message: 'timed out 2', code: 'ETIMEDOUT' });
            api.get('/').replyWithError({ message: 'timed ou